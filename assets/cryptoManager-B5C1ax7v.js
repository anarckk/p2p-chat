class c{keyPair=null;publicKeyExport=null;privateKeyExport=null;initialized=!1;DB_NAME="p2p-chat";DB_VERSION=2;db=null;SECURITY_KEYS_STORE="security_keys";async init(){if(this.initialized)return;if(await this.initIndexedDB(),await this.loadFromStorage()){this.initialized=!0,console.log("[Crypto] Keys loaded from storage");return}await this.generateKeyPair(),this.initialized=!0,console.log("[Crypto] New key pair generated")}async initIndexedDB(){return new Promise((e,o)=>{const r=indexedDB.open(this.DB_NAME,this.DB_VERSION);r.onerror=()=>{console.error("[Crypto] Failed to open database:",r.error),o(r.error)},r.onsuccess=()=>{this.db=r.result,e()},r.onupgradeneeded=t=>{const i=t.target.result;i.objectStoreNames.contains(this.SECURITY_KEYS_STORE)||(i.createObjectStore(this.SECURITY_KEYS_STORE,{keyPath:"id"}),console.log("[Crypto] Created security_keys store"))}})}async generateKeyPair(){this.keyPair=await window.crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:"SHA-256"},!0,["sign","verify"]),await this.exportAndStoreKeys()}async exportAndStoreKeys(){if(!this.keyPair)throw new Error("Key pair not initialized");try{const e=await window.crypto.subtle.exportKey("spki",this.keyPair.publicKey);this.publicKeyExport=this.arrayBufferToBase64(e);const o=await window.crypto.subtle.exportKey("pkcs8",this.keyPair.privateKey);this.privateKeyExport=this.arrayBufferToBase64(o),await this.storeToIndexedDB()}catch(e){throw console.error("[Crypto] Failed to export keys:",e),e}}async loadFromStorage(){try{this.db||await this.initIndexedDB();const r=this.db.transaction([this.SECURITY_KEYS_STORE],"readonly").objectStore(this.SECURITY_KEYS_STORE).get("my_keys");return new Promise(t=>{r.onsuccess=async()=>{const i=r.result;if(!i){t(!1);return}try{this.publicKeyExport=i.publicKey,this.privateKeyExport=await this.decryptPrivateKey(i.privateKey),await this.importKeys(),t(!0)}catch(a){console.error("[Crypto] Failed to load keys:",a),t(!1)}},r.onerror=()=>{console.error("[Crypto] Failed to read keys:",r.error),t(!1)}})}catch(e){return console.error("[Crypto] Failed to load from storage:",e),!1}}async importKeys(){if(!this.publicKeyExport||!this.privateKeyExport)throw new Error("No exported keys to import");try{const e=this.base64ToArrayBuffer(this.publicKeyExport),o=await window.crypto.subtle.importKey("spki",e,{name:"RSASSA-PKCS1-v1_5",hash:"SHA-256"},!0,["verify"]),r=this.base64ToArrayBuffer(this.privateKeyExport),t=await window.crypto.subtle.importKey("pkcs8",r,{name:"RSASSA-PKCS1-v1_5",hash:"SHA-256"},!0,["sign"]);this.keyPair={publicKey:o,privateKey:t}}catch(e){throw console.error("[Crypto] Failed to import keys:",e),e}}async storeToIndexedDB(){if(!this.publicKeyExport||!this.privateKeyExport)throw new Error("No keys to store");try{this.db||await this.initIndexedDB();const e=await this.encryptPrivateKey(this.privateKeyExport),t=this.db.transaction([this.SECURITY_KEYS_STORE],"readwrite").objectStore(this.SECURITY_KEYS_STORE).put({id:"my_keys",publicKey:this.publicKeyExport,privateKey:e,createdAt:Date.now()});return new Promise((i,a)=>{t.onsuccess=()=>{console.log("[Crypto] Keys stored to IndexedDB"),i()},t.onerror=()=>{console.error("[Crypto] Failed to store keys:",t.error),a(t.error)}})}catch(e){throw console.error("[Crypto] Failed to store to IndexedDB:",e),e}}async encryptPrivateKey(e){const o=localStorage.getItem("p2p_user_info_meta");if(!o)return e;try{const t=JSON.parse(o).peerId||"default-key",i=t.length;let a="";for(let s=0;s<e.length;s++)a+=String.fromCharCode(e.charCodeAt(s)^t.charCodeAt(s%i));return window.btoa(a)}catch{return e}}async decryptPrivateKey(e){const o=localStorage.getItem("p2p_user_info_meta");if(!o)return e;try{const t=JSON.parse(o).peerId||"default-key",i=t.length,a=window.atob(e);let s="";for(let n=0;n<a.length;n++)s+=String.fromCharCode(a.charCodeAt(n)^t.charCodeAt(n%i));return s}catch{return e}}async sign(e){if(!this.keyPair)throw new Error("Key pair not initialized");try{const r=new TextEncoder().encode(e),t=await window.crypto.subtle.sign("RSASSA-PKCS1-v1_5",this.keyPair.privateKey,r);return this.arrayBufferToBase64(t)}catch(o){throw console.error("[Crypto] Failed to sign data:",o),o}}async verify(e,o,r){try{const t=this.base64ToArrayBuffer(r),i=await window.crypto.subtle.importKey("spki",t,{name:"RSASSA-PKCS1-v1_5",hash:"SHA-256"},!1,["verify"]),s=new TextEncoder().encode(e),n=this.base64ToArrayBuffer(o);return await window.crypto.subtle.verify("RSASSA-PKCS1-v1_5",i,n,s)}catch(t){return console.error("[Crypto] Verify failed:",t),!1}}getPublicKey(){if(!this.publicKeyExport)throw new Error("Public key not available");return this.publicKeyExport}getPrivateKey(){if(!this.privateKeyExport)throw new Error("Private key not available");return this.privateKeyExport}async regenerate(){this.keyPair=null,this.publicKeyExport=null,this.privateKeyExport=null,await this.generateKeyPair(),console.log("[Crypto] Key pair regenerated")}async clear(){try{this.db||await this.initIndexedDB();const r=this.db.transaction([this.SECURITY_KEYS_STORE],"readwrite").objectStore(this.SECURITY_KEYS_STORE).delete("my_keys");return new Promise(t=>{r.onsuccess=()=>{this.keyPair=null,this.publicKeyExport=null,this.privateKeyExport=null,this.initialized=!1,console.log("[Crypto] Keys cleared"),t()},r.onerror=()=>{console.error("[Crypto] Failed to clear keys:",r.error),t()}})}catch(e){console.error("[Crypto] Failed to clear keys:",e)}}arrayBufferToBase64(e){const o=new Uint8Array(e);let r="";for(let t=0;t<o.byteLength;t++){const i=o[t];i!==void 0&&(r+=String.fromCharCode(i))}return window.btoa(r)}base64ToArrayBuffer(e){const o=window.atob(e),r=new Uint8Array(o.length);for(let t=0;t<o.length;t++)r[t]=o.charCodeAt(t);return r.buffer}close(){this.db&&(this.db.close(),this.db=null,console.log("[Crypto] Database closed"))}}const l=new c;export{l as cryptoManager};
