class l{keyPair=null;publicKeyExport=null;privateKeyExport=null;initialized=!1;DB_NAME="p2p-chat";DB_VERSION=2;db=null;SECURITY_KEYS_STORE="security_keys";static sharedDB=null;static sharedDBInit=null;async init(){if(console.log("[Crypto] init: Starting..."),this.initialized&&this.keyPair&&this.publicKeyExport&&this.privateKeyExport){console.log("[Crypto] init: Already initialized, validating...");try{await this.sign("validation-test"),console.log("[Crypto] init: Existing keys are valid");return}catch(i){console.log("[Crypto] Existing keys are invalid, reinitializing...",i),this.initialized=!1}}this.initialized&&(!this.keyPair||!this.publicKeyExport||!this.privateKeyExport)&&(console.log("[Crypto] Initialized flag is true but keys are incomplete, reinitializing..."),this.initialized=!1),console.log("[Crypto] init: Initializing IndexedDB..."),await this.initIndexedDB(),console.log("[Crypto] init: IndexedDB initialized"),console.log("[Crypto] init: Loading from storage...");const e=await this.loadFromStorage();if(console.log("[Crypto] init: Load from storage result =",e),e)if(this.keyPair&&this.publicKeyExport&&this.privateKeyExport){this.initialized=!0,console.log("[Crypto] Keys loaded from storage");return}else console.log("[Crypto] Load reported success but keys are incomplete, regenerating...");if(console.log("[Crypto] init: Generating new key pair..."),await this.generateKeyPair(),this.keyPair&&this.publicKeyExport&&this.privateKeyExport)this.initialized=!0,console.log("[Crypto] New key pair generated");else throw new Error("[Crypto] Failed to generate key pair: state incomplete after generation")}async initIndexedDB(){if(l.sharedDBInit){console.log("[Crypto] initIndexedDB: Waiting for shared DB initialization..."),this.db=await l.sharedDBInit,console.log("[Crypto] initIndexedDB: Shared DB ready");return}if(l.sharedDB){console.log("[Crypto] initIndexedDB: Using existing shared DB"),this.db=l.sharedDB;return}console.log("[Crypto] initIndexedDB: Creating new shared DB initialization"),l.sharedDBInit=new Promise((e,i)=>{const r=indexedDB.open(this.DB_NAME,this.DB_VERSION),t=setTimeout(()=>{console.error("[Crypto] initIndexedDB: Timeout after 10 seconds"),l.sharedDBInit=null,i(new Error("IndexedDB initialization timeout"))},1e4);r.onerror=()=>{clearTimeout(t),console.error("[Crypto] Failed to open database:",r.error),l.sharedDBInit=null,i(r.error)},r.onsuccess=()=>{clearTimeout(t),console.log("[Crypto] initIndexedDB: Database opened successfully"),this.db=r.result,l.sharedDB=this.db,e(this.db)},r.onupgradeneeded=o=>{console.log("[Crypto] initIndexedDB: onupgradeneeded triggered, oldVersion =",o.oldVersion);const s=o.target.result,a=["avatars","messages","devices","security_keys"];for(const n of a)if(!s.objectStoreNames.contains(n)){const c=s.createObjectStore(n,{keyPath:"id"});console.log("[Crypto] Created store:",n),n==="avatars"?c.createIndex("peerId","peerId",{unique:!1}):n==="messages"?(c.createIndex("toPeerId","toPeerId",{unique:!1}),c.createIndex("timestamp","timestamp",{unique:!1})):n==="devices"&&c.createIndex("username","username",{unique:!1})}console.log("[Crypto] initIndexedDB: All stores created/verified")},r.onblocked=()=>{console.log("[Crypto] initIndexedDB: Database open blocked - waiting for other connections to close")}}),await l.sharedDBInit,console.log("[Crypto] initIndexedDB: Initialization complete")}async generateKeyPair(){this.keyPair=await window.crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:"SHA-256"},!0,["sign","verify"]),await this.exportAndStoreKeys()}async exportAndStoreKeys(){if(!this.keyPair)throw new Error("Key pair not initialized");try{const e=await window.crypto.subtle.exportKey("spki",this.keyPair.publicKey);this.publicKeyExport=this.arrayBufferToBase64(e);const i=await window.crypto.subtle.exportKey("pkcs8",this.keyPair.privateKey);this.privateKeyExport=this.arrayBufferToBase64(i),await this.storeToIndexedDB()}catch(e){throw console.error("[Crypto] Failed to export keys:",e),e}}async loadFromStorage(){try{this.db||await this.initIndexedDB();const r=this.db.transaction([this.SECURITY_KEYS_STORE],"readonly").objectStore(this.SECURITY_KEYS_STORE).get("my_keys");return new Promise(t=>{r.onsuccess=async()=>{const o=r.result;if(!o){t(!1);return}try{this.publicKeyExport=o.publicKey,this.privateKeyExport=await this.decryptPrivateKey(o.privateKey),await this.importKeys(),this.keyPair?t(!0):(console.error("[Crypto] importKeys succeeded but keyPair is null"),this.publicKeyExport=null,this.privateKeyExport=null,t(!1))}catch(s){console.error("[Crypto] Failed to load keys:",s),this.publicKeyExport=null,this.privateKeyExport=null,this.keyPair=null,t(!1)}},r.onerror=()=>{console.error("[Crypto] Failed to read keys:",r.error),t(!1)}})}catch(e){return console.error("[Crypto] Failed to load from storage:",e),!1}}async importKeys(){if(!this.publicKeyExport||!this.privateKeyExport)throw new Error("No exported keys to import");try{const e=this.base64ToArrayBuffer(this.publicKeyExport),i=await window.crypto.subtle.importKey("spki",e,{name:"RSASSA-PKCS1-v1_5",hash:"SHA-256"},!0,["verify"]),r=this.base64ToArrayBuffer(this.privateKeyExport),t=await window.crypto.subtle.importKey("pkcs8",r,{name:"RSASSA-PKCS1-v1_5",hash:"SHA-256"},!0,["sign"]);this.keyPair={publicKey:i,privateKey:t}}catch(e){throw console.error("[Crypto] Failed to import keys:",e),e}}async storeToIndexedDB(){if(!this.publicKeyExport||!this.privateKeyExport)throw new Error("No keys to store");try{this.db||await this.initIndexedDB();const e=await this.encryptPrivateKey(this.privateKeyExport),t=this.db.transaction([this.SECURITY_KEYS_STORE],"readwrite").objectStore(this.SECURITY_KEYS_STORE).put({id:"my_keys",publicKey:this.publicKeyExport,privateKey:e,createdAt:Date.now()});return new Promise((o,s)=>{t.onsuccess=()=>{console.log("[Crypto] Keys stored to IndexedDB"),o()},t.onerror=()=>{console.error("[Crypto] Failed to store keys:",t.error),s(t.error)}})}catch(e){throw console.error("[Crypto] Failed to store to IndexedDB:",e),e}}async encryptPrivateKey(e){const i=localStorage.getItem("p2p_user_info_meta");if(!i)return e;try{const t=JSON.parse(i).peerId||"default-key",o=t.length;let s="";for(let a=0;a<e.length;a++)s+=String.fromCharCode(e.charCodeAt(a)^t.charCodeAt(a%o));return window.btoa(s)}catch{return e}}async decryptPrivateKey(e){const i=localStorage.getItem("p2p_user_info_meta");if(!i)return e;try{const t=JSON.parse(i).peerId||"default-key",o=t.length,s=window.atob(e);let a="";for(let n=0;n<s.length;n++)a+=String.fromCharCode(s.charCodeAt(n)^t.charCodeAt(n%o));return a}catch{return e}}async sign(e){if(!this.keyPair)throw new Error("Key pair not initialized");try{const r=new TextEncoder().encode(e),t=await window.crypto.subtle.sign("RSASSA-PKCS1-v1_5",this.keyPair.privateKey,r);return this.arrayBufferToBase64(t)}catch(i){throw console.error("[Crypto] Failed to sign data:",i),i}}async verify(e,i,r){try{const t=this.base64ToArrayBuffer(r),o=await window.crypto.subtle.importKey("spki",t,{name:"RSASSA-PKCS1-v1_5",hash:"SHA-256"},!1,["verify"]),a=new TextEncoder().encode(e),n=this.base64ToArrayBuffer(i);return await window.crypto.subtle.verify("RSASSA-PKCS1-v1_5",o,n,a)}catch(t){return console.error("[Crypto] Verify failed:",t),!1}}getPublicKey(){if(!this.publicKeyExport)throw new Error("Public key not available");return this.publicKeyExport}getPrivateKey(){if(!this.privateKeyExport)throw new Error("Private key not available");return this.privateKeyExport}async regenerate(){this.keyPair=null,this.publicKeyExport=null,this.privateKeyExport=null,await this.generateKeyPair(),console.log("[Crypto] Key pair regenerated")}async clear(){try{this.db||await this.initIndexedDB();const r=this.db.transaction([this.SECURITY_KEYS_STORE],"readwrite").objectStore(this.SECURITY_KEYS_STORE).delete("my_keys");return new Promise(t=>{r.onsuccess=()=>{this.keyPair=null,this.publicKeyExport=null,this.privateKeyExport=null,this.initialized=!1,console.log("[Crypto] Keys cleared"),t()},r.onerror=()=>{console.error("[Crypto] Failed to clear keys:",r.error),t()}})}catch(e){console.error("[Crypto] Failed to clear keys:",e)}}arrayBufferToBase64(e){const i=new Uint8Array(e);let r="";for(let t=0;t<i.byteLength;t++){const o=i[t];o!==void 0&&(r+=String.fromCharCode(o))}return window.btoa(r)}base64ToArrayBuffer(e){const i=window.atob(e),r=new Uint8Array(i.length);for(let t=0;t<i.length;t++)r[t]=i.charCodeAt(t);return r.buffer}close(){this.db&&(this.db.close(),this.db=null,console.log("[Crypto] Database closed"))}}const y=new l;export{y as cryptoManager};
